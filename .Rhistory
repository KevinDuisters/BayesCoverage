lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
# manual things to make plot look nice (be careful in generalizing this code)
box()
if(w==1){
points(y=c(-lambda,lambda,-lambda,lambda),x=c(max(xgrid[regimeU==4]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),min(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white")) # discontinuity jump at lambda
}
if(w < 1){
if(ta==0){points(y=c(-lambda,lambda,-lambda,lambda),x=c(min(xgrid[regimeU==3]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),max(xgrid[regimeL==3])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white")) # discontinuity jump at lambda
}else{
points(y=c(-lambda,0,0,lambda),x=c(-ta,-ta,ta,ta),
col=c("black","blue","black","blue"),pch=rep(21,4),bg=c("black","white","black","white")) # discontinuity jump at lambda
}
}
#------------------------------------------------------------------------------------------------------------------------#
# Left
lambda <- 5
h <- 0.01
xgrid <- seq(-20-lambda,20+lambda,h)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist)
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist)
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=ranges,asp=1)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(G(xgrid - lambda) + G(-xgrid - lambda))/g(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","-","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
# manual things to make plot look nice (be careful in generalizing this code)
box()
if(w==1){
points(y=c(-lambda,lambda,-lambda,lambda),x=c(max(xgrid[regimeU==4]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),min(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white")) # discontinuity jump at lambda
}
if(w < 1){
if(ta==0){points(y=c(-lambda,lambda,-lambda,lambda),x=c(min(xgrid[regimeU==3]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),max(xgrid[regimeL==3])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white")) # discontinuity jump at lambda
}else{
points(y=c(-lambda,0,0,lambda),x=c(-ta,-ta,ta,ta),
col=c("black","blue","black","blue"),pch=rep(21,4),bg=c("black","white","black","white")) # discontinuity jump at lambda
}
}
#------------------------------------------------------------------------------------------------------------------------#
if(right==T){
# Right
plot(theta0seq,xU.sup,type="n",xlim=ranges,ylim=ranges,ylab=expression(paste(X[U],(theta[0])," and ",{X[L]}(theta[0]))),col="black",xlab=expression(theta[0]),asp=1)
if(ta==0){ # this is a manual trick, not exact
abline(h=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=2,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(h=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","-","II","I"),side=2,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=2,at=c(-ta,ta),line=1)
}
abline(v=c(-lambda,lambda),lty=3,col="grey")
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=1,at=c(-lambda,lambda))
polygon(x=c(theta0seq[theta0seq<(-lambda)],sort(theta0seq[theta0seq<(-lambda)],decreasing=T)),y=c(xL.sup[theta0seq<(-lambda)],(xL.inf[theta0seq<(-lambda)])[order(theta0seq[theta0seq<(-lambda)],decreasing=T)]),col="blue",border=NA,density=20)
polygon(x=c(theta0seq[theta0seq>(lambda)],sort(theta0seq[theta0seq>(lambda)],decreasing=T)),y=c(xU.sup[theta0seq>(lambda)],(xU.inf[theta0seq>(lambda)])[order(theta0seq[theta0seq>(lambda)],decreasing=T)]),col="black",border=NA,density=20)
#plot(theta0seq[theta0seq>(lambda)],xU.sup[theta0seq>(lambda)],type="l")
#lines(theta0seq[theta0seq>(lambda)],xU.inf[theta0seq>(lambda)],type="l",col="red")
#polygon(c(theta0seq[theta0seq>lambda],rev(theta0seq[theta0seq>lambda])),c(xU.inf[theta0seq>lambda],rev(xU.sup[theta0seq>lambda])))
lines(theta0seq[theta0seq<(-lambda)],xU.sup[theta0seq<(-lambda)])
lines(theta0seq[theta0seq>(lambda)],xU.sup[theta0seq>(lambda)])
lines(theta0seq[theta0seq<(-lambda)],xU.inf[theta0seq<(-lambda)],lty=2)
lines(theta0seq[theta0seq>(lambda)],xU.inf[theta0seq>(lambda)],lty=2)
lines(theta0seq[theta0seq<(-lambda)],xL.sup[theta0seq<(-lambda)],col="blue")
lines(theta0seq[theta0seq>(lambda)],xL.sup[theta0seq>(lambda)],col="blue")
lines(theta0seq[theta0seq<(-lambda)],xL.inf[theta0seq<(-lambda)],lty=2,col="blue")
lines(theta0seq[theta0seq>(lambda)],xL.inf[theta0seq>(lambda)],lty=2,col="blue")
legend("topleft",c(expression(paste("sup ",X[U])),expression(paste("inf ",X[U])),expression(paste("sup ",X[L])),expression(paste("inf ",X[L]))),
lty=c(1,2,1,2),col=c("black","black","blue","blue"),ncol=2,bg="white",box.col="white",seg.len=2)
# manual things to make plot look nice (be careful in generalizing this code)
box()
if(w==1){
points(x=c(-lambda,lambda,-lambda,lambda),y=c(min(xgrid[regimeU==4]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),max(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white"))
}
if(w < 1){
if(ta==0){
points(x=c(-lambda,lambda,-lambda,lambda),y=c(min(xgrid[regimeU==4]),max(xgrid[regimeU==3]),min(xgrid[regimeL==3]),max(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white"))
segments(x0=0,x1=0,y0=min(xgrid[Ugrid==0]),y1=max(xgrid[Ugrid==0]),lwd=1.5,col="blue")
segments(x0=0,x1=0,y0=min(xgrid[Lgrid==0]),y1=max(xgrid[Lgrid==0]),lwd=1.5,col="blue")
points(x=c(0,0,0,0),y=c(min(xgrid[Ugrid==0]),min(xgrid[Ugrid==0]),min(xgrid[Lgrid==0]),max(xgrid[Lgrid==0])),col=c(1,"blue",1,"blue"),pch=rep(21,4),bg=c("white","black","white","blue"))
}else{
points(x=c(-lambda,lambda,-lambda,lambda),y=c(min(xgrid[regimeU==4]),ta,-ta,max(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white"))
segments(x0=0,x1=0,y0=min(xgrid[Ugrid==0]),y1=max(xgrid[Ugrid==0]),lwd=1.5,col="blue")
segments(x0=0,x1=0,y0=min(xgrid[Lgrid==0]),y1=max(xgrid[Lgrid==0]),lwd=1.5,col="blue")
points(x=c(0,0,0,0),y=c(min(xgrid[Ugrid==0]),min(xgrid[Ugrid==0]),min(xgrid[Lgrid==0]),max(xgrid[Lgrid==0])),col=c(1,"blue",1,"blue"),pch=rep(21,4),bg=c("white","black","white","blue"))
}
}
} # end if right==T
dev.off()
#--------------------------------------------------------------------------------------------------------------------#
# On frequentist coverage of Bayesian credible sets for estimation of the mean under constraints
# Duisters & Schmidt-Hieber
# Math Institute, Leiden University
# Oct 2019
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# source functions
library(rmutil) #dlaplace in densities
source("functions/getU.R")
#--------------------------------------------------------------------------------------------------------------------#
# Plots
#--------------------------------------------------------------------------------------------------------------------#
# Fig: Visualize L,U and inverse xL, xU
#--------------------------------------------------------------------------------------------------------------------#
# set density of interest
dist <- "Lap"
#dist <- "t3"
#dist <- "Normal"
#--------------------------------------------------------------------------------------------------------------------#
# code chunk to localize g, G, Ginv to memory
if(dist=="Lap"){
g <- function(x,theta0=0){dlaplace(x,m=theta0,s=1)}
G <- function(x,theta0=0){plaplace(x,m=theta0,s=1)}
Ginv <- function(p){qlaplace(p)}
}
if(dist=="Normal"){
g <- function(x,theta0=0){dnorm(x,theta0,1)}
G <- function(x,theta0=0){pnorm(x,theta0,1)}
Ginv <- function(p){qnorm(p)}  # make precise by always considering small p as opposed to large
}
if(dist=="t3"){
g <- function(x,theta0=0){dt(x,3)}
G <- function(x,theta0=0){pt(x,3)}
Ginv <- function(p){qt(p,3)}
}
#--------------------------------------------------------------------------------------------------------------------#
# set parameters
alpha <- 0.05
#w <- 1
w<-0.2
##--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# Visualize
if(w==1){pdf("Figures/figLU.pdf",width=9)}else{pdf("Figures/figSI1.pdf",width=9)}  # w=0.2}
right <- F # excluded inversion figures (December '19)
#par(mfrow=c(1,1))
par(mfrow=c(1,2))
ranges <- c(-10,10)
#--------------------------------------------------------------------------------------------------------------------#
# New Left (lambda = 0.5)
lambda <- 0.5
h <- 0.01
xgrid <- seq(-20-lambda,20+lambda,h)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist)
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist)
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=ranges,asp=1)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(G(xgrid - lambda) + G(-xgrid - lambda))/g(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","-","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
# manual things to make plot look nice (be careful in generalizing this code)
box()
if(w==1){
points(y=c(-lambda,lambda,-lambda,lambda),x=c(max(xgrid[regimeU==4]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),min(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white")) # discontinuity jump at lambda
}
if(w < 1){
if(ta==0){points(y=c(-lambda,lambda,-lambda,lambda),x=c(min(xgrid[regimeU==3]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),max(xgrid[regimeL==3])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white")) # discontinuity jump at lambda
}else{
points(y=c(-lambda,0,0,lambda),x=c(-ta,-ta,ta,ta),
col=c("black","blue","black","blue"),pch=rep(21,4),bg=c("black","white","black","white")) # discontinuity jump at lambda
}
}
#------------------------------------------------------------------------------------------------------------------------#
# Left
lambda <- 5
h <- 0.01
xgrid <- seq(-20-lambda,20+lambda,h)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist)
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist)
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=ranges,asp=1)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(G(xgrid - lambda) + G(-xgrid - lambda))/g(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","-","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
# manual things to make plot look nice (be careful in generalizing this code)
box()
if(w==1){
points(y=c(-lambda,lambda,-lambda,lambda),x=c(max(xgrid[regimeU==4]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),min(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white")) # discontinuity jump at lambda
}
if(w < 1){
if(ta==0){points(y=c(-lambda,lambda,-lambda,lambda),x=c(min(xgrid[regimeU==3]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),max(xgrid[regimeL==3])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white")) # discontinuity jump at lambda
}else{
points(y=c(-lambda,0,0,lambda),x=c(-ta,-ta,ta,ta),
col=c("black","blue","black","blue"),pch=rep(21,4),bg=c("black","white","black","white")) # discontinuity jump at lambda
}
}
#------------------------------------------------------------------------------------------------------------------------#
if(right==T){
# Right
plot(theta0seq,xU.sup,type="n",xlim=ranges,ylim=ranges,ylab=expression(paste(X[U],(theta[0])," and ",{X[L]}(theta[0]))),col="black",xlab=expression(theta[0]),asp=1)
if(ta==0){ # this is a manual trick, not exact
abline(h=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=2,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(h=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","-","II","I"),side=2,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=2,at=c(-ta,ta),line=1)
}
abline(v=c(-lambda,lambda),lty=3,col="grey")
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=1,at=c(-lambda,lambda))
polygon(x=c(theta0seq[theta0seq<(-lambda)],sort(theta0seq[theta0seq<(-lambda)],decreasing=T)),y=c(xL.sup[theta0seq<(-lambda)],(xL.inf[theta0seq<(-lambda)])[order(theta0seq[theta0seq<(-lambda)],decreasing=T)]),col="blue",border=NA,density=20)
polygon(x=c(theta0seq[theta0seq>(lambda)],sort(theta0seq[theta0seq>(lambda)],decreasing=T)),y=c(xU.sup[theta0seq>(lambda)],(xU.inf[theta0seq>(lambda)])[order(theta0seq[theta0seq>(lambda)],decreasing=T)]),col="black",border=NA,density=20)
#plot(theta0seq[theta0seq>(lambda)],xU.sup[theta0seq>(lambda)],type="l")
#lines(theta0seq[theta0seq>(lambda)],xU.inf[theta0seq>(lambda)],type="l",col="red")
#polygon(c(theta0seq[theta0seq>lambda],rev(theta0seq[theta0seq>lambda])),c(xU.inf[theta0seq>lambda],rev(xU.sup[theta0seq>lambda])))
lines(theta0seq[theta0seq<(-lambda)],xU.sup[theta0seq<(-lambda)])
lines(theta0seq[theta0seq>(lambda)],xU.sup[theta0seq>(lambda)])
lines(theta0seq[theta0seq<(-lambda)],xU.inf[theta0seq<(-lambda)],lty=2)
lines(theta0seq[theta0seq>(lambda)],xU.inf[theta0seq>(lambda)],lty=2)
lines(theta0seq[theta0seq<(-lambda)],xL.sup[theta0seq<(-lambda)],col="blue")
lines(theta0seq[theta0seq>(lambda)],xL.sup[theta0seq>(lambda)],col="blue")
lines(theta0seq[theta0seq<(-lambda)],xL.inf[theta0seq<(-lambda)],lty=2,col="blue")
lines(theta0seq[theta0seq>(lambda)],xL.inf[theta0seq>(lambda)],lty=2,col="blue")
legend("topleft",c(expression(paste("sup ",X[U])),expression(paste("inf ",X[U])),expression(paste("sup ",X[L])),expression(paste("inf ",X[L]))),
lty=c(1,2,1,2),col=c("black","black","blue","blue"),ncol=2,bg="white",box.col="white",seg.len=2)
# manual things to make plot look nice (be careful in generalizing this code)
box()
if(w==1){
points(x=c(-lambda,lambda,-lambda,lambda),y=c(min(xgrid[regimeU==4]),min(xgrid[regimeU==3]),max(xgrid[regimeL==3]),max(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white"))
}
if(w < 1){
if(ta==0){
points(x=c(-lambda,lambda,-lambda,lambda),y=c(min(xgrid[regimeU==4]),max(xgrid[regimeU==3]),min(xgrid[regimeL==3]),max(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white"))
segments(x0=0,x1=0,y0=min(xgrid[Ugrid==0]),y1=max(xgrid[Ugrid==0]),lwd=1.5,col="blue")
segments(x0=0,x1=0,y0=min(xgrid[Lgrid==0]),y1=max(xgrid[Lgrid==0]),lwd=1.5,col="blue")
points(x=c(0,0,0,0),y=c(min(xgrid[Ugrid==0]),min(xgrid[Ugrid==0]),min(xgrid[Lgrid==0]),max(xgrid[Lgrid==0])),col=c(1,"blue",1,"blue"),pch=rep(21,4),bg=c("white","black","white","blue"))
}else{
points(x=c(-lambda,lambda,-lambda,lambda),y=c(min(xgrid[regimeU==4]),ta,-ta,max(xgrid[regimeL==4])),
col=c("black","black","blue","blue"),pch=rep(21,4),bg=c("black","white","blue","white"))
segments(x0=0,x1=0,y0=min(xgrid[Ugrid==0]),y1=max(xgrid[Ugrid==0]),lwd=1.5,col="blue")
segments(x0=0,x1=0,y0=min(xgrid[Lgrid==0]),y1=max(xgrid[Lgrid==0]),lwd=1.5,col="blue")
points(x=c(0,0,0,0),y=c(min(xgrid[Ugrid==0]),min(xgrid[Ugrid==0]),min(xgrid[Lgrid==0]),max(xgrid[Lgrid==0])),col=c(1,"blue",1,"blue"),pch=rep(21,4),bg=c("white","black","white","blue"))
}
}
} # end if right==T
dev.off()
#----------------------------------------------------------------------------------------------------------------------------#
# Duisters, Schmidt-Hieber
# Sep 2019
#----------------------------------------------------------------------------------------------------------------------------#
# Figure tail decay
#----------------------------------------------------------------------------------------------------------------------------#
# load library
library(rmutil)
#library(RColorBrewer)
#----------------------------------------------------------------------------------------------------------------------------#
# settings
h <- 0.001
alphaseq <- seq(h,1-h,h)
#wseq <- c(alphaseq,1)
wseq <- seq(0,1,h)
lambda1 <- 0.5
densities <- c("N(0,1)","Lap(0,1)","t10","t5","t3","t2","Cauchy(0,1)")
cols <- c("black","blue","darkgreen","chartreuse4","aquamarine3","green","red")
ltys <- c(5,1,3,3,3,3,4)
ld <- length(densities)
# lambda sensitivity
lambdaseq <- c(0.25,0.5,0.75,1,2.5,5,7.5)
ll <- length(lambdaseq)
lambdaltys <- c(2,1,3,4,5,1,6)
lambdacols <- rep(cols[which(densities=="Lap(0,1)")],ll)
#----------------------------------------------------------------------------------------------------------------------------#
# result
mat <- matrix(NA,length(alphaseq),length(wseq))
rownames(mat) <- alphaseq
colnames(mat) <- wseq
tail<- lapply(1:ld,function(l) mat)
Laptails <- lapply(1:ll,function(l)mat)
#----------------------------------------------------------------------------------------------------------------------------#
# loop
for(d in 1:ld){
dens <- densities[d]
if(dens=="N(0,1)"){
g <- function(x){dnorm(x,0,1)}
G <- function(x){pnorm(x,0,1)}
Ginv <- function(p){qnorm(p,0,1)}
}
if(dens=="t10"){
g <- function(x){dt(x,10)}
G <- function(x){pt(x,10)}
Ginv <- function(p){qt(p,10)}
}
if(dens=="t5"){
g <- function(x){dt(x,5)}
G <- function(x){pt(x,5)}
Ginv <- function(p){qt(p,5)}
}
if(dens=="t3"){
g <- function(x){dt(x,3)}
G <- function(x){pt(x,3)}
Ginv <- function(p){qt(p,3)}
}
if(dens=="t2"){
g <- function(x){dt(x,2)}
G <- function(x){pt(x,2)}
Ginv <- function(p){qt(p,2)}
}
if(dens=="Lap(0,1)"){
g <- function(x){dlaplace(x)}
G <- function(x){plaplace(x)}
Ginv <- function(p){qlaplace(p)}
}
if(dens=="Cauchy(0,1)"){
g <- function(x){dcauchy(x)}
G <- function(x){pcauchy(x)}
Ginv <- function(p){qcauchy(p)}
}
for(i in 1:(length(alphaseq)-1)){
alpha <- alphaseq[i]
for(j in (i+1):length(wseq)){
w <- wseq[j]
q <- Ginv((alpha/(1+alpha))*(1 + ((1-w)/w)*g(lambda1)) )
if(q < 0){tail[[d]][i,j] <- (G(2*q)<(2*alpha^2)/(1-alpha^2))}else{tail[[d]][i,j] <- NA}
# lambda plot
if(dens=="Lap(0,1)"){
for(l in 1:ll){
ql <- Ginv((alpha/(1+alpha))*(1 + ((1-w)/w)*g(lambdaseq[l])))
if(ql < 0){Laptails[[l]][i,j] <- (G(2*ql)<(2*alpha^2)/(1-alpha^2))}else{Laptails[[l]][i,j] <- NA}
}
}
}
}
}
# tail decay
pdf("Figures/figtail.pdf",width=9,height=9)
plot(0,0,xlim=range(wseq),ylim=range(alphaseq),ylab=expression(alpha),xlab="w",type="n",asp=1,cex.axis=2,cex.lab=2)
#polygon(x=c(-2,2,-2,-2),y=c(-2,2,2,-2),col="lightgrey",border="white")
abline(h=seq(0,1,0.1),lty=2,col="lightgrey")
abline(v=seq(0,1,0.1),lty=2,col="lightgrey")
for(a in seq(0,1,0.1)){segments(x0=-1,x1=a,y0=a,y1=a,lty=2,col="white")}
box()
for(d in 1:7){
alphaline <- apply(tail[[d]],2,function(c)alphaseq[min(which(c==T))])
lines(wseq,alphaline,lty=ltys[d],col=cols[d],lwd=2)
}
legend(x=0,y=1,densities[ld:1],lty=ltys[ld:1],col=cols[ld:1],lwd=rep(2,ld),bg="white",cex=2)
dev.off()
# lambda sensitivity
pdf("Figures/figtaillambdaLap.pdf",width=9,height=9)
plot(0,0,xlim=range(wseq),ylim=range(alphaseq),ylab=expression(alpha),xlab="w",type="n",asp=1,cex.axis=2,cex.lab=2)
#polygon(x=c(-2,2,-2,-2),y=c(-2,2,2,-2),col="lightgrey",border="white")
abline(h=seq(0,1,0.1),lty=2,col="lightgrey")
abline(v=seq(0,1,0.1),lty=2,col="lightgrey")
for(a in seq(0,1,0.1)){segments(x0=-1,x1=a,y0=a,y1=a,lty=2,col="white")}
box()
for(l in 1:ll){
alphaline <- apply(Laptails[[l]],2,function(c)alphaseq[min(which(c==T))])
lines(wseq,alphaline,lty=lambdaltys[l],col=lambdacols[l],lwd=2)
}
mylabels <- sapply(1:ll,function(l)as.expression(bquote(lambda==.(lambdaseq[l]))))
legend(x=0,y=1,mylabels,lty=lambdaltys,col=lambdacols,lwd=rep(2,ll),bg="white",cex=2)
dev.off()
w <- 0.2 # Supplemental
if(w==1){pdf("Figures/figcov.pdf",width=9)}else{pdf("Figures/SFcov.pdf",width=9)}
par(mfcol=c(2,2),xpd=F,mar=c(4,4,2,2))
lambdas <- c(0.5,5)
for(lambda in lambdas){
thetaseq <- seq(lambda+0.005,lambda+14,0.005)
coverage(thetaseq,alpha,lambda,w,dist="Normal",plot.cov=T,cols)
coverage(thetaseq,alpha,lambda,w,dist="Lap",plot.cov=T,cols)
}
dev.off()
# bottom
if(w==1){pdf("Figures/figcovbottom.pdf",width=9)}else{pdf("Figures/SFcovbottom.pdf",width=9)}
par(mfrow=c(2,2),xpd=F,mar=c(4,4,2,2))
lambdas <- c(0.5,5)
for(lambda in lambdas){
thetaseq <- seq(lambda+0.005,lambda+14,0.005)
coverage(thetaseq,alpha,lambda,w,dist="t3",plot.cov=T,cols)
}
dev.off()
setwd("~/surfdrive/Confidence (KD)/Git")
#--------------------------------------------------------------------------------------------------------------------#
# On frequentist coverage of Bayesian credible sets for estimation of the mean under constraints
# Duisters & Schmidt-Hieber
# Math Institute, Leiden University
# Nov 2019
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# libraries
library(rmutil) #dlaplace
source("functions/getU.R")
source("functions/coverage.R")
# Plot Coverage
alpha <- 0.05
cols <- c("grey","green","red","blue","orange","magenta")
w <- 1
w <- 0.2 # Supplemental
if(w==1){pdf("Figures/figcov.pdf",width=9)}else{pdf("Figures/SFcov.pdf",width=9)}
par(mfcol=c(2,2),xpd=F,mar=c(4,4,2,2))
lambdas <- c(0.5,5)
for(lambda in lambdas){
thetaseq <- seq(lambda+0.005,lambda+14,0.005)
coverage(thetaseq,alpha,lambda,w,dist="Normal",plot.cov=T,cols)
coverage(thetaseq,alpha,lambda,w,dist="Lap",plot.cov=T,cols)
}
dev.off()
# bottom
if(w==1){pdf("Figures/figcovbottom.pdf",width=9)}else{pdf("Figures/SFcovbottom.pdf",width=9)}
par(mfrow=c(2,2),xpd=F,mar=c(4,4,2,2))
lambdas <- c(0.5,5)
for(lambda in lambdas){
thetaseq <- seq(lambda+0.005,lambda+14,0.005)
coverage(thetaseq,alpha,lambda,w,dist="t3",plot.cov=T,cols)
}
dev.off()
=0.08*45+0.22*15
0.08*45+0.22*15
(0.08*45+0.22*15)*0.4
(0.08*45+0.22*15)*0.4/12
60+0.7*0.6*45
80*4.5
70+0.7*0.6*45
90*4.5
100+0.7*0.6*45
120*4.5

library(rmutil) #dlaplace in densities
source("functions/getU.R")
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
## Fig: Visualize L,U
## Manual input Laplace density
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# set universal parameters
alpha <- 0.05
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# Universal code chunk for plotting for some w and lambda
code.chunk <- function(lambda,w,alpha,h=0.01){
xgrid <- seq(-20-lambda,20+lambda,h)
ranges <- c(-12,12)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist="Lap")
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist="Lap")
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=1.5*ranges)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(plaplace(xgrid - lambda) + plaplace(-xgrid - lambda))/dlaplace(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
box()
}
#--------------------------------------------------------------------------------------------------------------------#
# Visualize
pdf("Figures/figLU.pdf",width=12,height=6)
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
#------------------------------------------------------------------------------------------------------------------------#
dev.off()
#--------------------------------------------------------------------------------------------------------------------#
# On frequentist coverage of Bayesian credible sets for estimation of the mean under constraints
# Duisters & Schmidt-Hieber
# Math Institute, Leiden University
# Oct 2019
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# source functions
library(rmutil) #dlaplace in densities
source("functions/getU.R")
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
## Fig: Visualize L,U
## Manual input Laplace density
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# set universal parameters
alpha <- 0.05
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# Universal code chunk for plotting for some w and lambda
code.chunk <- function(lambda,w,alpha,h=0.01){
xgrid <- seq(-20-lambda,20+lambda,h)
ranges <- c(-10,10)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist="Lap")
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist="Lap")
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=1.5*ranges)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(plaplace(xgrid - lambda) + plaplace(-xgrid - lambda))/dlaplace(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
box()
}
#--------------------------------------------------------------------------------------------------------------------#
# Visualize
pdf("Figures/figLU.pdf",width=12,height=6)
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
#------------------------------------------------------------------------------------------------------------------------#
dev.off()
pdf("Figures/figLU.pdf",width=6,height=3)
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
#------------------------------------------------------------------------------------------------------------------------#
dev.off()
pdf("Figures/figLU.pdf",width=12,height=6)
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
#------------------------------------------------------------------------------------------------------------------------#
dev.off()
par(mfrow=c(1,1))
code.chunk(lambda=1,w=0.25,alpha) # left
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
pdf("Figures/figLU.pdf",width=9,height=4)
par(mfrow=c(1,3))
par(mfrow=c(1,1))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
#------------------------------------------------------------------------------------------------------------------------#
dev.off()
#--------------------------------------------------------------------------------------------------------------------#
# On frequentist coverage of Bayesian credible sets for estimation of the mean under constraints
# Duisters & Schmidt-Hieber
# Math Institute, Leiden University
# Oct 2019
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# source functions
library(rmutil) #dlaplace in densities
source("functions/getU.R")
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
## Fig: Visualize L,U
## Manual input Laplace density
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# set universal parameters
alpha <- 0.05
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# Universal code chunk for plotting for some w and lambda
code.chunk <- function(lambda,w,alpha,h=0.01){
xgrid <- seq(-20-lambda,20+lambda,h)
ranges <- c(-10,10)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist="Lap")
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist="Lap")
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=1.5*ranges)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(plaplace(xgrid - lambda) + plaplace(-xgrid - lambda))/dlaplace(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
box()
}
#--------------------------------------------------------------------------------------------------------------------#
# Visualize
pdf("Figures/figLU.pdf",width=9,height=4)
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
#------------------------------------------------------------------------------------------------------------------------#
dev.off()
pdf("Figures/figLU.pdf",width=9,height=6)
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
#------------------------------------------------------------------------------------------------------------------------#
dev.off()
pdf("Figures/figLU.pdf",width=12,height=4.5)
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha) # left
code.chunk(lambda=5,w=0.25,alpha) # mid
code.chunk(lambda=5,w=1,alpha) # right
#------------------------------------------------------------------------------------------------------------------------#
dev.off()
par(mfrow=c(1,3),pty="s")
code.chunk(lambda=1,w=0.25,alpha,output="size") # left
code.chunk(lambda=5,w=0.25,alpha,output="size") # mid
code.chunk(lambda=5,w=1,alpha,output="size") # right
#--------------------------------------------------------------------------------------------------------------------#
# On frequentist coverage of Bayesian credible sets for estimation of the mean under constraints
# Duisters & Schmidt-Hieber
# Math Institute, Leiden University
# Oct 2019
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# source functions
library(rmutil) #dlaplace in densities
source("functions/getU.R")
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
## Fig: Visualize L,U
## Manual input Laplace density
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# set universal parameters
alpha <- 0.05
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# Universal code chunk for plotting for some w and lambda
code.chunk <- function(lambda,w,alpha,output,h=0.01){
xgrid <- seq(-20-lambda,20+lambda,h)
ranges <- c(-10,10)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist="Lap")
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist="Lap")
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
if(output=="LU"){
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=1.5*ranges)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(plaplace(xgrid - lambda) + plaplace(-xgrid - lambda))/dlaplace(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
box()
}
if(output=="size"){
}
}
par(mfrow=c(1,3),pty="s")
code.chunk(lambda=1,w=0.25,alpha,output="LU") # left
code.chunk(lambda=5,w=0.25,alpha,output="LU") # mid
code.chunk(lambda=5,w=1,alpha,output="LU") # right
pdf("Figures/figLU.pdf",width=7,height=7)
par(mfrow=c(1,3),pty="s")
code.chunk(lambda=1,w=0.25,alpha,output="LU") # left
code.chunk(lambda=5,w=0.25,alpha,output="LU") # mid
code.chunk(lambda=5,w=1,alpha,output="LU") # right
dev.off()
pdf("Figures/figLU.pdf")
par(mfrow=c(1,3),pty="s")
code.chunk(lambda=1,w=0.25,alpha,output="LU") # left
code.chunk(lambda=5,w=0.25,alpha,output="LU") # mid
code.chunk(lambda=5,w=1,alpha,output="LU") # right
dev.off()
pdf("Figures/figLU.pdf",width=12,height=4.5)
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha,output="LU") # left
code.chunk(lambda=5,w=0.25,alpha,output="LU") # mid
code.chunk(lambda=5,w=1,alpha,output="LU") # right
dev.off()
plot(xgrid,xgrid,type="n",xlab="x",ylab=expression(paste("size ",HPD[alpha](x))),ylim=c(0,10))
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha,output="size") # left
xgrid=seq(0,1,0.1)
plot(xgrid,xgrid,type="n",xlab="x",ylab=expression(paste("size ",HPD[alpha](x))),ylim=c(0,10))
#--------------------------------------------------------------------------------------------------------------------#
# On frequentist coverage of Bayesian credible sets for estimation of the mean under constraints
# Duisters & Schmidt-Hieber
# Math Institute, Leiden University
# Oct 2019
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# source functions
library(rmutil) #dlaplace in densities
source("functions/getU.R")
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
## Fig: Visualize L,U
## Manual input Laplace density
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# set universal parameters
alpha <- 0.05
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# Universal code chunk for plotting for some w and lambda
code.chunk <- function(lambda,w,alpha,output,h=0.01){
xgrid <- seq(-20-lambda,20+lambda,h)
ranges <- c(-10,10)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist="Lap")
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist="Lap")
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
if(output=="LU"){
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=1.5*ranges)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(plaplace(xgrid - lambda) + plaplace(-xgrid - lambda))/dlaplace(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
box()
}
if(output=="size"){
plot(xgrid,xgrid,type="n",xlab="x",ylab=expression(paste("size of ",HPD[alpha](x))),ylim=c(0,10))
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(plaplace(xgrid - lambda) + plaplace(-xgrid - lambda))/dlaplace(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
sizes <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
Ui <- Ugrid[i]
Li <- Lgrid[i]
if(Ui > lambda & Li < (-lambda) ){sizes[i] <- Ui - Li - 2*lambda}else{
sizes[i] <- Ui - Li
}
}
}
}
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha,output="size") # left
lines(xgrid,sizes)
#--------------------------------------------------------------------------------------------------------------------#
# On frequentist coverage of Bayesian credible sets for estimation of the mean under constraints
# Duisters & Schmidt-Hieber
# Math Institute, Leiden University
# Oct 2019
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# source functions
library(rmutil) #dlaplace in densities
source("functions/getU.R")
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
## Fig: Visualize L,U
## Manual input Laplace density
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# set universal parameters
alpha <- 0.05
#--------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------------#
# Universal code chunk for plotting for some w and lambda
code.chunk <- function(lambda,w,alpha,output,h=0.01){
xgrid <- seq(-20-lambda,20+lambda,h)
ranges <- c(-10,10)
Ugrid <- Lgrid <- regimeU <- regimeL <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
x <- xgrid[i]
out.U <-getU(x,alpha,lambda,w,dist="Lap")
Ugrid[i] <- out.U$val
regimeU[i] <- out.U$regime
out.L <- getU(-x,alpha,lambda,w,dist="Lap")
Lgrid[i] <- -(out.L$val)
regimeL[i] <- out.L$regime
}
if(output=="LU"){
theta0seq <- c(seq(-lambda-20,-lambda-h,h),seq(lambda+h,lambda+20,h))
xU.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Ugrid>=theta0))]})
xU.sup <- sapply(theta0seq,function(theta0){xgrid[max(which(Ugrid<=theta0))]})
xL.inf <- sapply(theta0seq,function(theta0){xgrid[min(which(Lgrid>=theta0))]})
xL.sup <-sapply(theta0seq,function(theta0){xgrid[max(which(Lgrid<=theta0))]})
plot(xgrid,xgrid,ylab=expression(paste(L[alpha](x)," and ",U[alpha](x))),xlab=expression(x),type="n",xlim=ranges,ylim=1.5*ranges)
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(plaplace(xgrid - lambda) + plaplace(-xgrid - lambda))/dlaplace(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
for(r in 0:5){
reg <- which(regimeU==r)
lines(xgrid[reg],Ugrid[reg],col="black")
reg <- which(regimeL==r)
lines(xgrid[reg],Lgrid[reg],col="blue")
}
mtext(c(expression(-lambda),expression(lambda)),line=-1.5,side=2,at=c(-lambda,lambda))
legend("topleft",c(expression(U[alpha]),expression(L[alpha])),lty=c(1,1),col=c("black","blue"),horiz=F,bg="white",box.col="white",seg.len=2)
box()
}
if(output=="size"){
plot(xgrid,xgrid,type="n",xlab="x",ylab=expression(paste("size of ",HPD[alpha](x))),ylim=c(0,10))
abline(h=c(-lambda,lambda),lty=3,col="grey")
ta <-max(0,xgrid[((w/(1-w))*(plaplace(xgrid - lambda) + plaplace(-xgrid - lambda))/dlaplace(xgrid)) <= (alpha/(1-alpha))])
if(ta==0){ # this is a manual trick, not exact
abline(v=c(max(xgrid[regimeU==5]),max(xgrid[regimeU==4]),min(xgrid[regimeU==2]),min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","III","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])+max(xgrid[regimeU==4]))/2,(max(xgrid[regimeU==4])+min(xgrid[regimeU==2]))/2,(min(xgrid[regimeU==2])+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
}else{
abline(v=c(max(xgrid[regimeU==5]),-ta,ta,min(xgrid[regimeU==1])),lty=3,col="grey")
mtext(c("I","IV","","II","I"),side=1,adj=0.5,line=-1.5,at=c((min(ranges)+max(xgrid[regimeU==5]))/2,(max(xgrid[regimeU==5])-ta)/2,(-ta+ta)/2,(ta+min(xgrid[regimeU==1]))/2,(min(xgrid[regimeU==1])+max(ranges))/2))
mtext(c(expression(-t[alpha]),expression(t[alpha])),side=1,at=c(-ta,ta),line=1)
}
sizes <- numeric(length(xgrid))
for(i in 1:length(xgrid)){
Ui <- Ugrid[i]
Li <- Lgrid[i]
if(Ui > lambda & Li < (-lambda) ){sizes[i] <- Ui - Li - 2*lambda}else{
sizes[i] <- Ui - Li
}
}
lines(xgrid,sizes)
}
}
code.chunk(lambda=1,w=0.25,alpha,output="size") # left
par(mfrow=c(1,3))
code.chunk(lambda=1,w=0.25,alpha,output="size") # left
code.chunk(lambda=5,w=0.25,alpha,output="size") # mid
code.chunk(lambda=5,w=1,alpha,output="size") # right
code.chunk(lambda=1,w=0.25,alpha,output="LU") # left
